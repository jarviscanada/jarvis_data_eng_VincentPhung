# Introduction
This Java grep application functions similarly to the Linux command-line tool "grep" and allows for use on different platforms with this Java implementation. It was developed using core Java 8 and managed with Maven for dependency handling, packaging, and compilation. There are two implementations for this application. The first implementation uses traditional Java syntax which includes for and while loops. The second implementation uses the lambda function and Stream APIs to implement the methods, creating more clean and concise code. The code was tested using a logger class namely sl4fj, and it was deployed on a container using docker.   

# Quick Start
There are three alternative ways to run the application

# 1. Running the application by targeting the classpath and class files
```
mvn clean package
java -classpath target/classes ca.jrvs.apps.grep.JavaGrepImp arg1 arg2 arg3

//Example of arguments: .*Romeo.*Juliet.* /data/txt /log/grep.out
```
# 2. Running the jar file generated by Maven
```
mvn clean package
java -cp target/grep-1.0-SNAPSHOT.jar ca.jrvs.apps.grep.JavaGrepImp arg1 arg2 arg3
```
# 3. Downloading the Docker Image and running the container
```
docker pull vincentp05/grep
docker run --rm \
-v `pwd`/data:/data -v `pwd`/log:/log \
$vincentp05/grep arg1 arg2 arg3
```

# Implemenation
The application consists of a few methods that filter through directories and files, and there is a method called process that executes the other methods in order.
## Pseudocode
```
matchedLines = []
for file in listFilesRecursively(rootDir)
  for line in readLines(file)
      if containsPattern(line)
        matchedLines.add(line)
writeToFile(matchedLines)
```

## Performance Issue

The Java grep application encounters memory issues due to how the application is designed, matching lines are stored in memory. So when dealing with large files there are performance issues. The second implementation using the lambda function and Stream APIs helps with the performance issues when dealing with larger files, by reducing the amount of data stored in memory. The features/methods from using the lambda function and Stream APIs allow for data manipulation on a collection without having to store the data in a data structure such as an array list. One other way to avoid issues with larger files is to increase the maximum JVM heap size, which addresses the issue of not having enough memory.

# Test
How did you test your application manually? (e.g. prepare sample data, run some test cases manually, compare result)
Testing was done using a Logger instance from the Sl4fj logging framework. Logger lines were placed in crucial points in the application to check for correctness. The IntelliJ debugger tool was also used to test the logic on the various methods. Lastly, various different arguments were used to manually test the application.

# Deployment
A docker file was provided to create the docker image of this application. After having maven clean and package the application, the docker image was created based on the docker file. Which was then pushed to Docker Hub.

# Improvement
1. Look into more methods to reduce the amount of heap memory required
2. Make a more user-friendly interface with prompts 
3. Make more test cases, to test more input scenarios